bring Err
bring Str
bring {parseObject, parseArray} from "json-parser.fg"

fun start_server(port: as int) -> as nthg decl


fun flush() -> as nthg decl


fun set_route(method: as str, path: as str, handler: unknown, handler2: unknown) -> as nthg decl


fun set_middleware(middleware: unknown) -> as nthg decl


fun send_response(client_socket: as int, status: as str, content_type: as str, body: as str, keepAlive: as int) -> as str decl


fun send(socket: as int, data: as str, len: as int, flags: as int) -> as nthg decl


fun strlen(s: as str) -> as int decl


fun len(s: as str) -> as int {
  return strlen(s)
}


fun generate_response(content_type: as str, body: as str) -> as str {
  return "HTTP/1.1 200 OK\r\nContent-Type: " + content_type + "\r\nContent-Length: " + len(body) + "\r\n\r\n" + body
}


fun json_response(data: as str) -> str {
  return "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: " + len(data) + "\r\n\r\n" + data
}


fun statusString(inout status: int) -> str {
  if (100) {
    return "100 Continue"
  } or if (101) {
    return "101 Switching Protocols"
  } or if (200) {
    return "200 OK"
  } or if 201 {
    return "201 Created"
  } or if 202 {
    return "202 Accepted"
  } or if 204 {
    return "204 No Content"
  } or if 301 {
    return "301 Moved Permanently"
  } or if 302 {
    return "302 Found"
  } or if 303 {
    return "303 See Other"
  } or if 304 {
    return "304 Not Modified"
  } or if 307 {
    return "307 Temporary Redirect"
  } or if 308 {
    return "308 Permanent Redirect"
  } or if 400 {
    return "400 Bad Request"
  } or if 401 {
    return "401 Unauthorized"
  } or if 403 {
    return "403 Forbidden"
  } or if 404 {
    return "404 Not Found"
  } or if 405 {
    return "405 Method Not Allowed"
  } or if 408 {
    return "408 Request Timeout"
  } or if 500 {
    return "500 Internal Server Error"
  } or if 501 {
    return "501 Not Implemented"
  } or if 502 {
    return "502 Bad Gateway"
  } or if 503 {
    return "503 Service Unavailable"
  } or if 504 {
    return "504 Gateway Timeout"
  } else {
    return String(status)
  }
}


fun my_request_handler(client_socket: as int, req: as str, endpoint: as str) -> as nthg {
  if (endpoint == "/json") {
    const json_response_data: str = "{\"message\": \"Hello, JSON!\"}"
    send_response(client_socket, "200 OK", "application/json", json_response_data, 1)
  } or if (endpoint == "/text") {
    const plain_text_response: str = "Hello, World!"
    send_response(client_socket, "200 OK", "text/plain", plain_text_response, 1)
  } else {
    const not_found_response: str = "Not Found"
    send_response(client_socket, "404 Not Found", "text/plain", not_found_response, 1)
  }
}


fun split(s: str, delimiter: str) -> Vec::String {
  var result: Vec::String = new Vec::String()
  var part: str = ""
  for var i = 0 to Str::length(s) - 1 {
    if (Str::int8ToString(Int8(s[i])) == delimiter) {
      if (Str::length(part)) {
        result.add(part)
      }
      part = "" 
    } or if (i + 1 < Str::length(s) && String(Str::int8ToString(Int8(s[i])) + Str::int8ToString(Int8(s[i + 1]))) == delimiter) {
      if (Str::length(part)) {
        result.add(part)
      }
      i = i + 1 
      part = "" 
    } else {
      part = part + Str::int8ToString(Int8(s[i])) 
    }
  }
  if Str::length(part) > 0 {
    result.add(part)
  }
  return result
}

type Header = {
  Host: str,
  Connection: str,
  sec_ch_ua: str,
  sec_ch_ua_mobile: bool,
  sec_ch_ua_platform: str,
  Upgrade_Insecure_Requests: int,
  User_Agent: str,
  Sec_Purpose: str,
  Purpose: str,
  Accept: str,
  Sec_Fetch_Site: str,
  Sec_Fetch_Mode: str,
  Sec_Fetch_User: bool,
  Sec_Fetch_Dest: str,
  Accept_Encoding: str,
  Accept_Language: str,
  content_type: str,
  content_length: int
}
type HttpRequest = {
  method: str,
  endpoint: str,
  version: str,
  headers: Header,
  body: str
}

fun parse_request(req_str: as str) -> HttpRequest, Err::Result {
  var lines: Vec::String = split(req_str, "\n")
  var method: str, endpoint: str, version: str    /; Headers start from the second line onwards

  if (lines.size() == 0) {
    return {

    }, new Err::Result("Could not parse request", Err::CODE.FAILED, "In parse_request")
  }
  var body: str
  var hasBody = false
  var header_map: Header
  for var i = 0 to lines.size() - 1 {
    if i == 0 {
      var firstLineParts: Vec::String = split(lines.get(i), " ")
      method, endpoint, version = firstLineParts.get(0), firstLineParts.get(1), firstLineParts.get(2)        /; Headers start from the second line onwards
 
    } else {
      var header_parts: Vec::String = split(lines.get(i), ":")
      if (hasBody) {
        body = body + lines.get(i) 
        continue
      }
      if (header_parts.size() > 1) {
        header_parts.set(1, Str::trimInPlace(header_parts.get(1)))
      }
      if header_parts.get(0) == "Host" {
        header_map.Host = header_parts.get(1) 
      } or if header_parts.get(0) == "Connection" {
        header_map.Connection = header_parts.get(1) 
      } or if header_parts.get(0) == "sec-ch-ua" {
        header_map.sec_ch_ua = header_parts.get(1) 
      } or if header_parts.get(0) == "sec-ch-ua-mobile" {
        header_map.sec_ch_ua_mobile = header_parts.get(1) == "?1" 
      } or if header_parts.get(0) == "sec-ch-ua-platform" {
        header_map.sec_ch_ua_platform = header_parts.get(1) 
      } or if header_parts.get(0) == "Upgrade-Insecure-Requests" {
        header_map.Upgrade_Insecure_Requests = Int32(header_parts.get(1)) 
      } or if header_parts.get(0) == "User-Agent" {
        header_map.User_Agent = header_parts.get(1) 
      } or if header_parts.get(0) == "Accept" {
        header_map.Accept = header_parts.get(1) 
      } or if header_parts.get(0) == "Sec-Fetch-Site" {
        header_map.Sec_Fetch_Site = header_parts.get(1) 
      } or if header_parts.get(0) == "Sec-Fetch-Mode" {
        header_map.Sec_Fetch_Mode = header_parts.get(1) 
      } or if header_parts.get(0) == "Sec-Fetch-User" {
        header_map.Sec_Fetch_User = header_parts.get(1) == "?1" 
      } or if header_parts.get(0) == "Sec-Fetch-Dest" {
        header_map.Sec_Fetch_Dest = header_parts.get(1) 
      } or if header_parts.get(0) == "Accept-Encoding" {
        header_map.Accept_Encoding = header_parts.get(1) 
      } or if header_parts.get(0) == "Accept-Language" {
        header_map.Accept_Language = header_parts.get(1) 
      } or if header_parts.get(0) == "Content-Type" {
        header_map.content_type = header_parts.get(1) 
      } or if header_parts.get(0) == "Content-Length" {
        header_map.content_length = Int32(header_parts.get(1)) + 0 
      } or if header_parts.get(0) == "\r" {
        hasBody = true 
        continue
      }
    }
  }
  return {
    method: method,
    endpoint: endpoint,
    version: version,
    headers: header_map,
    body: Str::trimInPlace(body)
  }, Nir
}


fun log_middleware(client_socket: as int, req_str: as str, endpoint: as str) -> as nthg {  /;print("log_middleware: ", req_str, "\n")

  flush()
}


fun printVector(inout vec: Vec::String) -> as nthg {
  for var i = 0 to vec.size() - 1 {
    print(vec.get(i), "\n")
    flush()
  }
  flush()
}


fun post_request_handler(client_socket: as int, req: as str, endpoint: as str) -> as nthg {  /; print("POST Request", Str::subStr(req, "\r\n\r\n"), "\n")

  var Req: HttpRequest, err: Err::Result = parse_request(req)    /;print("Req: ", Req, "\n")

  var mp: Map::String = parseObject(Req.body)
  print("NAME ", mp.get("address"), "\n")
  flush()
  const plain_text_response: str = "Hello, World!"
  send_response(client_socket, "200 OK", "text/plain", plain_text_response, 1)
}

type HttpResponseType = {
  status: int,
  content_type: str,
  body: str,
  keepAlive: int
}
class HttpResponse {
  var res: HttpResponseType
  var clientSocket: int
  init(clientSocket: int) -> nthg {
    self.clientSocket = clientSocket 
  }


  send(res: HttpResponseType) -> Err::Result {
    res.keepAlive = 1 
    if (res.content_type == "") {
      res.content_type = "text/plain" 
    }
    if (res.body == "") {
      return new Err::Result("Could not send response", Err::CODE.FAILED, "In send")
    }
    var status = statusString(res.status)
    var r: str = send_response(clientSocket, status, res.content_type, res.body, res.keepAlive)
    print("SSS", r)
    return Nir
  }


}

fun my_request_handler2(client_socket: as int, req: as str, endpoint: as str, cRouteHandler: [( HttpRequest, HttpResponse ) -> nthg] ) -> as nthg {  /; print("POST Request", Str::subStr(req, "\r\n\r\n"), "\n")

  var Req: HttpRequest, err: Err::Result = parse_request(req)    /;print("Req: ", Req, "\n")

  /; var mp: Map::String = parseObject(Req.body)
    /; print("NAME ", mp.get("address"), "\n")
    /; flush()

  print(" Printint Endpoint From my_request_handler2 Route: ", endpoint, "\n")
  flush()
  const plain_text_response: str = "Hello, World!"
  cRouteHandler(Req, new HttpResponse(client_socket))
}


fun customRouteHandler(inout req: HttpRequest, inout res: HttpResponse) -> nthg {
  print(" Printint Endpoint From Custom Route: ", "\n")
  flush()
  var err: Err::Result = res.send({
    status: 200,
    content_type: "text/plain",
    body: "Hello, World!"
  })
  if (!(err == Nir)) {
    print(err.code, "\n")
    flush()
  }
}


fun customRouteHandler2(inout req: HttpRequest, inout res: HttpResponse) -> nthg {
  print(" Printint Endpoint From Custom Route2: ", "\n")
  flush()
  var err: Err::Result = res.send({
    status: 200,
    content_type: "text/plain",
    body: "Hello, World2!"
  })
  if (err != Nir) {
  /; print(err.getMessage(), "\n")

    flush()
  }
}


fun main() -> nthg {
  set_middleware(log_middleware)
  /; set_route("GET", "/json", my_request_handler)

  set_route("GET", "/", my_request_handler2, customRouteHandler)
  set_route("GET", "/hello", my_request_handler2, customRouteHandler2)
  /; set_route("GET", "/text", my_request_handler)
    /; set_route("POST", "/submit", post_request_handler)

  start_server(8080)
}

main()
/; class FGVortex {
  /;   var port: int
  /;   init(port: int) -> nthg {
  /;     self.port = port 
  /;   }

/;   addMiddleware(middleware: [( int, str, str ) -> nthg] ) -> as nthg {
  /;     set_middleware(middleware)
  /;   }

/;   start() -> as nthg {
  /;     start_server(self.port)
  /;   }

/;   setRoute(method: str, path: str, handler: [( int, str, str ) -> nthg] ) -> as nthg {
  /;     set_route(method, path, handler)
  /;   }

/; }

