type X = {
  x1: str,
  x2: int
}
type Complex = {
  a: int[3],
  j: X[2]
}
fun printNice() -> nthg {
    print("Not Nice")
  }

  fun outsidefun()-> nthg {
      print("Outsidefunction")
    }
class A {
  var a: int
  var b: str
  var d: deci
  var e: bool
  var obj: X 
  var arr: Complex[2]
  var obj2: Complex 
  init(a: int, b: str, yesD: deci, obj: X ) -> nthg {
    print("initCalled")
    self.a = a 
    self.b = b 
    d = yesD 
    self.obj = obj 
  }

  updateA() -> nthg {
    a = 100 
    self.d = 2.2 
    b = "Nice" 
  }

  printDefaults() -> nthg {
    print(a)
    print(b)
    print(d)
    print(e)
    print(obj)
    print(arr)
  }

  updateComplex(ar: Complex[2]) -> nthg {
    arr = ar 
  }

  printComplex() -> nthg {
    print(self.arr)
  }

  printAll() -> nthg {
    print(arr[0].j[0].x2)
    arr[0].j[0].x2= 2
    print("\n")
    print(arr[0].j[0].x2)
    print("\n")
    arr[0].j[1].x1= "WAY"
    print(arr[0].j[1].x1)
    print("\n")
    print(obj)
    print("\n")
    print(obj.x2)
    print("\n")
    print(obj.x1)
    print("\n")
    print(obj2)
    print("\n")
    obj2 = {
      j: [{
        x2: 2,
        x1: "Ge"
      }],
      a: [2 fill 1]
    } 
    print(obj2)
    print("\n")
    obj2 <- {

    } 
    print(obj2)
    print("\n")
    print(obj2.a)
    print("\n")
    print(obj2.j[0].x2)
    printNice()
    self.printNice()
    outsidefun()
  }

  printNice() -> nthg {
      print("Nice")
    }

}
{
    var a: A  = new A(2, "Hello", 3.3, {
  x1: "HI",
  x2: 45
})
a.printDefaults()
print("\n")
print("Before Update\n")
print(a.arr)
a.updateComplex([{
  a: [2 fill 5],
  j: [{
    x1: "yo",
    x2: 40
  }]
}])
print("\n")
a.printAll()
a.printNice()
printNice()
outsidefun()
  }
/#
class Animal {
   var x:int
   var k:str
  init(y:int) -> nthg {
    x = y
    print("Constructor Called\n")
  
  }
  getX() -> int {
   printSome(2,3)
   return 2
  }
  printSome(a:int,b:int) -> nthg {
    print("Sum of A and B with x"+Int32(a+b+x)+"\n")
  }
}
var d:Animal = new Animal(2)
print(d.getX())
d.printSome(3,45)
d.hi()



/#type obj = {
    i:int,
    s:str
  }
type k = {
  o: int,
  s: str,
  d: deci,
  i: int,
  ob:obj
}
type par = {
  u: str,
  g: k[2]
}
type t = {
  x: int,
  y: str,
  a: deci,
  b: bool,
  ar: par[1]
}
fun getGKA() -> k[2] {
  var gka: k  = {
  i:1022,
 o: 102,
  s: "sora"
  
}
var x:k[2] = new [gka]

    return x
  }

fun getT()-> t{
  var tt:t = {y:"NO",b:true,ar:[{u:"eeet",g:getGKA()}]}
  return tt
  }

fun getArr()-> t[2] {
var a:t[2] = new [{x:2,y:"hello",a:3.3,b:true,ar:[{u:"get",g:getGKA()}]}]
return a
  }
{
  var arr:t[2] = new [{x:300,y:"eee",a:4.3,b:true,ar:[{g:getGKA()}]}]
print(arr)
print("\n\n")
arr = new [{x:2}]
print(arr)
}
/#
{
    var x: int[100000] = new [100000 fill 2]
x = new [100 fill 10]
  print(x)
  }

/#
 type obj = {
    i:int,
    s:str
  }
type k = {
  o: int,
  s: str,
  d: deci,
  i: int,
  ob:obj
}
type par = {
  u: str,
  g: k[2]
}
type t = {
  x: int,
  y: str,
  a: deci,
  b: bool,
  ar: par[1]
}
fun getGKA() -> k[2] {
  var gka: k  = {
  i:1022,
 o: 102,
  s: "sora"
  
}
var x:k[2] = [gka]

    return x
  }

fun getT()-> t{
  var tt:t = {y:"NO",b:true,ar:[{u:"eeet",g:getGKA()}]}
  return tt
  }

fun getArr()-> t[2] {
var a:t[2] = [{x:2,y:"hello",a:3.3,b:true,ar:[{u:"get",g:getGKA()}]}]
return a
  }
{
  var arr:t[2] = [{x:300,y:"eee",a:4.3,b:true,ar:[{g:getGKA()}]}]
print(arr)
print("\n\n")
arr <- [{x:2}]
print(arr)
arr[0].ar[0].g = getGKA()
}
var sec:t[3] = [{a:3.5,ar:[{g:[{s:"god",i:12,ob:{s:"some",i:200}}]}]}]


