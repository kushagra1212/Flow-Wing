type T = {
  a:int 
}
type K = {
  j:T[2]
}
class B {
  var u:K

  init(u:K) -> nthg {
    self.u = u
  }

  getU() -> K {
    return u
  }
}

class A{
  var obj:T 

  init(obj:T) -> nthg {
    self.obj = obj 
  }

  printB(b:B) -> nthg {
    print(b.getU())
  }
}


fun getA(d:A) -> A {
 d.obj.a = 21
  return d
}
fun getAA(a:A) -> A {
  return getA(a)
}
fun createA() -> A {
  return new A({a:22})
}
var a:A = new A({a:1})
print(a.obj)
a = createA()
print(a.obj)
a = new A({a:322})
print(a.obj)
a.obj = {a:32}
print("After Pass")
print(a.printB(new B({j:[{a:2}]})))
/#
 type T2 = {
   d:deci 
  }

 type T1 = {
    a:int,
    b:str,
    c:T2,
    d:T2[2]
  }
class A {
type T3A = {
  u:str,
}

 var x:T1 
 var a:T3A
  init(x:T1) -> nthg {
    self.x = x
    a = {u:"Nice"}
  }
  

  printX() -> nthg {
    print(self.x)
  }
}

class B extends A  {

var a:deci
var j:int
var s:str
var k:deci
var u:int

init(y:T1) -> nthg {

super(y)
j = 2
a = 2.2
s = "hi"
}

  printX()-> nthg {
  print(u) 
    print(a,"\n",j,"\n",s,"\n",k)
      print("Not printing it ")
    }
}

var b:B = new B({a:2})
b.printX()
print(b.x)

/#

type X = {
  x1: str,
  x2: int
}
type Complex = {
  a: int[3],
  j: X[2]
}
fun printNice() -> nthg {
    print("Not Nice")
  }

  fun outsidefun()-> nthg {
      print("Outsidefunction")
}

class B {
var n:int 

  printN() -> nthg {
        print("This is n: "+n)
  }

}

class A {
  var a: int
  var b: str
  var d: deci
  var e: bool
  var obj: X 
  var arr: Complex[2]
  var obj2: Complex 
  init(a: int, b: str, yesD: deci, obj: X ) -> nthg {
    print("initCalled")
    self.a = a 
    self.b = b 
    d = yesD 
    self.obj = obj 
  }

  updateA() -> nthg {
    a = 100 
    self.d = 2.2 
    b = "Nice" 
  }

  printDefaults() -> nthg {
    print(a)
    print(b)
    print(d)
    print(e)
    print(obj)
    print(arr)
  }

  updateComplex(ar: Complex[2]) -> nthg {
    arr = ar 
  }

  printComplex() -> nthg {
    print(self.arr)
  }

  printAll() -> nthg {
    print(arr[0].j[0].x2)
    arr[0].j[0].x2= 2
    print("\n")
    print(arr[0].j[0].x2)
    print("\n")
    arr[0].j[1].x1= "WAY"
    print(arr[0].j[1].x1)
    print("\n")
    print(obj)
    print("\n")
    print(obj.x2)
    print("\n")
    print(obj.x1)
    print("\n")
    print(obj2)
    print("\n")
    obj2 = {
      j: [{
        x2: 2,
        x1: "Ge"
      }],
      a: [2 fill 1]
    } 
    print(obj2)
    print("\n")
    obj2 <- {

    } 
    print(obj2)
    print("\n")
    print(obj2.a)
    print("\n")
    print(obj2.j[0].x2)
    printNice()
    self.printNice()
    outsidefun()
  }

  printNice() -> nthg {
      print("Nice")
  }

  printBsa(b: A) -> nthg {
    b.a = 1212
   print("\n\n\n")
   b.printAll()
   print(self.b)
   print(b.a)
  }

  printBClass(d: B) -> nthg {
  
    d.printN()
  }

}
var a: A  = new A(2, "Hello", 3.3, {
  x1: "HI",
  x2: 45
})
a.printDefaults()
print("\n")
print("Before Update\n")
print(a.arr)
a.updateComplex([{
  a: [2 fill 5],
  j: [{
    x1: "yo",
    x2: 40
  }]
}])
print("\n")
a.printAll()
a.printNice()
printNice()
outsidefun()
var b:A = new A(5,"e",5.5,{
    x1:"s",
    x2:22
})
a.printBsa(new A(5,"e",5.5,{
        x1:"s",
            x2:22
})
  )
print(b.a)
/#
class Animal {
   var x:int
   var k:str
  init(y:int) -> nthg {
    x = y
    print("Constructor Called\n")
  
  }
  getX() -> int {
   printSome(2,3)
   return 2
  }
  printSome(a:int,b:int) -> nthg {
    print("Sum of A and B with x"+Int32(a+b+x)+"\n")
  }
}
var d:Animal = new Animal(2)
print(d.getX())
d.printSome(3,45)
d.hi()



/#type obj = {
    i:int,
    s:str
  }
type k = {
  o: int,
  s: str,
  d: deci,
  i: int,
  ob:obj
}
type par = {
  u: str,
  g: k[2]
}
type t = {
  x: int,
  y: str,
  a: deci,
  b: bool,
  ar: par[1]
}
fun getGKA() -> k[2] {
  var gka: k  = {
  i:1022,
 o: 102,
  s: "sora"
  
}
var x:k[2] = new [gka]

    return x
  }

fun getT()-> t{
  var tt:t = {y:"NO",b:true,ar:[{u:"eeet",g:getGKA()}]}
  return tt
  }

fun getArr()-> t[2] {
var a:t[2] = new [{x:2,y:"hello",a:3.3,b:true,ar:[{u:"get",g:getGKA()}]}]
return a
  }
{
  var arr:t[2] = new [{x:300,y:"eee",a:4.3,b:true,ar:[{g:getGKA()}]}]
print(arr)
print("\n\n")
arr = new [{x:2}]
print(arr)
}
/#
{
    var x: int[100000] = new [100000 fill 2]
x = new [100 fill 10]
  print(x)
  }

/#
 type obj = {
    i:int,
    s:str
  }
type k = {
  o: int,
  s: str,
  d: deci,
  i: int,
  ob:obj
}
type par = {
  u: str,
  g: k[2]
}
type t = {
  x: int,
  y: str,
  a: deci,
  b: bool,
  ar: par[1]
}
fun getGKA() -> k[2] {
  var gka: k  = {
  i:1022,
 o: 102,
  s: "sora"
  
}
var x:k[2] = [gka]

    return x
  }

fun getT()-> t{
  var tt:t = {y:"NO",b:true,ar:[{u:"eeet",g:getGKA()}]}
  return tt
  }

fun getArr()-> t[2] {
var a:t[2] = [{x:2,y:"hello",a:3.3,b:true,ar:[{u:"get",g:getGKA()}]}]
return a
  }
{
  var arr:t[2] = [{x:300,y:"eee",a:4.3,b:true,ar:[{g:getGKA()}]}]
print(arr)
print("\n\n")
arr <- [{x:2}]
print(arr)
arr[0].ar[0].g = getGKA()
}
var sec:t[3] = [{a:3.5,ar:[{g:[{s:"god",i:12,ob:{s:"some",i:200}}]}]}]


