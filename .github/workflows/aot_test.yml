# .github/workflows/aot-test-optimized.yml

name: AOT Tests (Optimized)

on: [pull_request]

jobs:
  aot_test:
    # You can experiment with larger runners for more speed, e.g., 'ubuntu-latest-4-cores'
    # This requires being on a paid GitHub plan.
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # This action sets up Docker Buildx, which is required for the caching feature.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # The core of the optimization. This step builds the image using the
      # GitHub Actions cache as a remote cache. On the first run, it builds
      # and saves the layers. On subsequent runs, it pulls unchanged layers
      # from the cache instead of rebuilding them.
      - name: Build and cache test image
        uses: docker/build-push-action@v5
        with:
          context: .
          # This should be the 'target' stage for your tests inside your Dockerfile.
          target: test-aot
          # We 'load' the image into the local Docker daemon so the next step can use it.
          load: true
          # We tag the image with a unique name. We'll reference this in the next step.
          tags: aot-test-image:${{ github.sha }}
          # Enable caching using the GitHub Actions cache backend.
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # This step now runs tests using the pre-built, cached image.
      # The 'env' section passes the image tag to docker-compose.
      - name: Run AOT tests
        env:
          # This environment variable will be used by docker-compose.yml
          AOT_IMAGE_TAG: aot-test-image:${{ github.sha }}
        run: >
          docker compose up
          --no-build
          --exit-code-from test-aot
          test-aot
